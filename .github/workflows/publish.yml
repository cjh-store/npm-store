name: 📦 Publish Packages

on:
  # 推送触发：主分支自动发布 + 标签发布
  push:
    branches:
      - main
      - master
    tags:
      - '*@*'  # 格式 package-name@version

  # 手动触发：选择性发布
  workflow_dispatch:
    inputs:
      packages:
        description: '选择要发布的包 (多选用逗号分隔，all表示全部)'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'cc-cli-run'
          - 'cc-git-tag'
          - 'cc-vite-progress'
          - '@cjh0/fetch-event-source'
          - '@cjh0/git-pro'

      force:
        description: '强制发布 (跳过版本检查)'
        required: false
        default: false
        type: boolean

jobs:
  publish:
    runs-on: ubuntu-latest
    if: "github.event_name == 'workflow_dispatch' || github.event_name == 'push' && (contains(github.ref, 'tags') || !contains(github.event.head_commit.message, '[skip ci]'))"

    permissions:
      contents: write      # 创建releases和标签
      issues: write       # semantic-release需要
      pull-requests: write # semantic-release需要
      id-token: write     # npm provenance

    steps:
      # 1. 检出代码
      - name: 🔄 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史，lerna需要
          token: ${{ secrets.GITHUB_TOKEN }}

      # 2. 设置Node.js环境
      - name: 🔧 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
          cache: 'yarn'

      # 3. 验证NPM认证（借鉴cc项目）
      - name: ✅ Verify NPM Authentication
        run: |
          echo "🔧 验证 NPM 认证..."

          # 检查 NPM_TOKEN 是否存在
          if [ -z "$NPM_TOKEN" ]; then
            echo "❌ NPM_TOKEN secret 未配置！"
            echo "请按照以下步骤配置："
            echo "1. 访问 https://www.npmjs.com/settings/tokens"
            echo "2. 生成 Automation 类型的 token"
            echo "3. 在 GitHub Settings > Secrets 中添加 NPM_TOKEN"
            exit 1
          fi

          # 验证 NPM 登录
          npm whoami || {
            echo "❌ NPM 认证失败！请检查 token 是否有效"
            echo "Token 前缀: ${NPM_TOKEN:0:8}..."
            exit 1
          }

          echo "✅ NPM 用户: $(npm whoami)"
          echo "✅ NPM 认证验证成功"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      # 4. 安装依赖
      - name: 📦 Install Dependencies
        run: yarn install --frozen-lockfile
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      # 5. 质量检查 - 构建所有包
      - name: 🔨 Build Packages
        run: |
          echo "🔨 开始构建需要构建的包..."

          # 检查并构建cc-vite-progress
          if [ -f "packages/cc-vite-progress/package.json" ]; then
            echo "📦 构建 cc-vite-progress..."
            cd packages/cc-vite-progress && yarn build && cd ../..
          fi

          # 检查并构建fetch-event-source
          if [ -f "packages/fetch-event-source/package.json" ]; then
            echo "📦 构建 fetch-event-source..."
            cd packages/fetch-event-source && npm run build && cd ../..
          fi

          # 检查并构建git-pro
          if [ -f "packages/git-pro/package.json" ]; then
            echo "📦 构建 git-pro..."
            cd packages/git-pro
            yarn build
            # 清理构建过程中产生的垃圾文件
            rm -f nul
            cd ../..
          fi

          echo "✅ 构建完成"

      # 6. 清理工作树
      - name: 🧹 Clean Working Tree
        run: |
          echo "🧹 清理工作树中的构建产物..."

          # 重置所有修改的文件（构建可能会修改一些文件）
          git checkout -- . 2>/dev/null || true

          # 删除未跟踪的文件
          git clean -fd

          # 检查工作树状态
          if [ -n "$(git status --porcelain)" ]; then
            echo "⚠️ 工作树仍有变更："
            git status --short
            echo "🔧 尝试提交这些变更..."
            git add -A
            git commit -m "chore: 自动提交构建产物 [skip ci]" || echo "没有需要提交的内容"
          else
            echo "✅ 工作树干净"
          fi

      # 7. Git配置 (lerna需要)
      - name: ⚙️ Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 8. 解析触发方式和包
      - name: 🎯 Parse Trigger & Packages
        id: parse
        run: |
          echo "🔍 分析触发方式..."

          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_type }}" == "tag" ]]; then
            # 标签触发：解析包名
            TAG_NAME="${{ github.ref_name }}"
            if [[ $TAG_NAME =~ ^(.+)@(.+)$ ]]; then
              PACKAGE_NAME="${BASH_REMATCH[1]}"
              PACKAGE_VERSION="${BASH_REMATCH[2]}"
              echo "trigger=tag" >> $GITHUB_OUTPUT
              echo "package=$PACKAGE_NAME" >> $GITHUB_OUTPUT
              echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
              echo "🏷️ 标签触发: $PACKAGE_NAME@$PACKAGE_VERSION"
            else
              echo "❌ 标签格式错误，应为 package@version"
              exit 1
            fi

          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # 手动触发
            echo "trigger=manual" >> $GITHUB_OUTPUT
            echo "packages=${{ github.event.inputs.packages }}" >> $GITHUB_OUTPUT
            echo "force=${{ github.event.inputs.force }}" >> $GITHUB_OUTPUT
            echo "🖱️ 手动触发: ${{ github.event.inputs.packages }}"

          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # 自动触发：推送到主分支
            echo "trigger=auto" >> $GITHUB_OUTPUT
            echo "🤖 自动触发: 检测变更并发布"

          else
            echo "❌ 未知触发方式"
            exit 1
          fi

      # 9. 智能发布包
      - name: 🚀 Publish Packages
        id: publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 确保npm已登录
          echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc

          # 切换到npm源
          npm config set registry https://registry.npmjs.org/

          TRIGGER="${{ steps.parse.outputs.trigger }}"

          # 初始化发布结果文件
          echo "" > /tmp/publish_results.txt

          if [[ "$TRIGGER" == "tag" ]]; then
            # 标签触发：发布特定包
            PACKAGE_NAME="${{ steps.parse.outputs.package }}"
            echo "🎯 发布单个包: $PACKAGE_NAME"

            # 查找包目录
            PACKAGE_DIR=""
            for dir in packages/*/; do
              if [ -f "${dir}package.json" ]; then
                PKG_NAME=$(node -p "require('./${dir}package.json').name")
                if [ "$PKG_NAME" = "$PACKAGE_NAME" ]; then
                  PACKAGE_DIR="$dir"
                  break
                fi
              fi
            done

            if [ -z "$PACKAGE_DIR" ]; then
              echo "❌ 找不到包: $PACKAGE_NAME"
              exit 1
            fi

            echo "📦 在目录 $PACKAGE_DIR 中发布包"
            cd "$PACKAGE_DIR"
            CURRENT_VERSION=$(node -p "require('./package.json').version")

            if npm publish --access public; then
              echo "✅ $PACKAGE_NAME@$CURRENT_VERSION" >> /tmp/publish_results.txt
            else
              echo "❌ $PACKAGE_NAME 发布失败" >> /tmp/publish_results.txt
            fi
            cd ../..

          elif [[ "$TRIGGER" == "manual" ]]; then
            # 手动触发：根据选择发布
            PACKAGES="${{ steps.parse.outputs.packages }}"

            if [[ "$PACKAGES" == "all" ]]; then
              echo "🚀 发布所有已变更的包"

              # 捕获lerna输出并解析
              if npx lerna publish --conventional-commits --no-verify-access --yes > /tmp/lerna_output.txt 2>&1; then
                echo "✅ Lerna发布成功"
                # 提取发布成功的包信息
                grep "Successfully published:" /tmp/lerna_output.txt || echo "未找到发布信息"
                grep -E "lerna success published.*@.*" /tmp/lerna_output.txt | sed 's/lerna success published /✅ /' >> /tmp/publish_results.txt
              else
                echo "❌ Lerna发布失败"
                cat /tmp/lerna_output.txt
                echo "❌ 发布失败" >> /tmp/publish_results.txt
                exit 1
              fi
            else
              echo "🎯 发布指定包: $PACKAGES"

              # 处理多个包的情况
              IFS=',' read -ra PKG_ARRAY <<< "$PACKAGES"
              for pkg in "${PKG_ARRAY[@]}"; do
                pkg=$(echo "$pkg" | xargs)  # 去除空格
                echo "📦 正在发布包: $pkg"

                # 查找包目录
                PACKAGE_DIR=""
                for dir in packages/*/; do
                  if [ -f "${dir}package.json" ]; then
                    PKG_NAME=$(node -p "require('./${dir}package.json').name")
                    if [ "$PKG_NAME" = "$pkg" ]; then
                      PACKAGE_DIR="$dir"
                      break
                    fi
                  fi
                done

                if [ -z "$PACKAGE_DIR" ]; then
                  echo "⚠️ 跳过不存在的包: $pkg"
                  echo "⚠️ $pkg (包不存在)" >> /tmp/publish_results.txt
                  continue
                fi

                echo "📦 在目录 $PACKAGE_DIR 中发布包 $pkg"
                cd "$PACKAGE_DIR"
                CURRENT_VERSION=$(node -p "require('./package.json').version")

                if npm publish --access public; then
                  echo "✅ $pkg@$CURRENT_VERSION" >> /tmp/publish_results.txt
                else
                  echo "❌ $pkg@$CURRENT_VERSION (发布失败)" >> /tmp/publish_results.txt
                fi
                cd ../..
              done
            fi

          elif [[ "$TRIGGER" == "auto" ]]; then
            # 自动触发：基于commit信息发布变更的包
            echo "🤖 自动检测并发布已变更的包"

            # 捕获lerna输出并解析发布信息
            if npx lerna publish --conventional-commits --no-verify-access --yes > /tmp/lerna_output.txt 2>&1; then
              echo "✅ Lerna自动发布成功"
              cat /tmp/lerna_output.txt

              # 提取发布成功的包信息
              if grep -q "Successfully published:" /tmp/lerna_output.txt; then
                echo "📦 发布的包:"
                grep -A 20 "Successfully published:" /tmp/lerna_output.txt | grep -E "^\s*-\s*.*@.*" | sed 's/^\s*-\s*/✅ /' >> /tmp/publish_results.txt
              elif grep -q "lerna success published.*@" /tmp/lerna_output.txt; then
                # 提取版本信息
                grep -E "lerna success published.*@.*" /tmp/lerna_output.txt | sed 's/lerna success published /✅ /' >> /tmp/publish_results.txt
              else
                echo "📦 未检测到需要发布的包变更" >> /tmp/publish_results.txt
              fi
            else
              echo "❌ Lerna自动发布失败"
              cat /tmp/lerna_output.txt
              echo "❌ 自动发布失败" >> /tmp/publish_results.txt
              exit 1
            fi

          else
            echo "❌ 未知触发类型: $TRIGGER"
            exit 1
          fi

          # 将发布结果保存为输出变量
          echo "PUBLISH_RESULTS<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/publish_results.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 10. 发布结果通知
      - name: 📊 Publish Summary
        if: always()
        run: |
          echo "## 📦 发布总结" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          TRIGGER="${{ steps.parse.outputs.trigger }}"

          echo "### 🎯 触发信息" >> $GITHUB_STEP_SUMMARY
          if [[ "$TRIGGER" == "tag" ]]; then
            echo "- **触发方式**: 🏷️ 标签触发" >> $GITHUB_STEP_SUMMARY
            echo "- **目标包**: ${{ steps.parse.outputs.package }}@${{ steps.parse.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "$TRIGGER" == "manual" ]]; then
            echo "- **触发方式**: 🖱️ 手动触发" >> $GITHUB_STEP_SUMMARY
            echo "- **发布范围**: ${{ steps.parse.outputs.packages }}" >> $GITHUB_STEP_SUMMARY
          elif [[ "$TRIGGER" == "auto" ]]; then
            echo "- **触发方式**: 🤖 自动触发" >> $GITHUB_STEP_SUMMARY
            echo "- **发布范围**: 检测到变更的包" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- **执行状态**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **执行时间**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Node版本**: $(node --version)" >> $GITHUB_STEP_SUMMARY
          echo "- **NPM用户**: $(npm whoami 2>/dev/null || echo 'N/A')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # 显示发布结果详情
          echo "### 📋 发布详情" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ steps.publish.outputs.PUBLISH_RESULTS }}" ]]; then
            echo "${{ steps.publish.outputs.PUBLISH_RESULTS }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # 统计发布结果
            SUCCESS_COUNT=$(echo "${{ steps.publish.outputs.PUBLISH_RESULTS }}" | grep -c "✅" || echo "0")
            FAIL_COUNT=$(echo "${{ steps.publish.outputs.PUBLISH_RESULTS }}" | grep -c "❌" || echo "0")

            echo "**📊 发布统计**:" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ 成功: ${SUCCESS_COUNT} 个包" >> $GITHUB_STEP_SUMMARY
            echo "- ❌ 失败: ${FAIL_COUNT} 个包" >> $GITHUB_STEP_SUMMARY
          else
            echo "暂无发布结果信息" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### 🔗 快速链接" >> $GITHUB_STEP_SUMMARY
          echo "- [📦 NPM Registry](https://www.npmjs.com/search?q=%40cjh0)" >> $GITHUB_STEP_SUMMARY
          echo "- [📝 Lerna文档](https://lerna.js.org/)" >> $GITHUB_STEP_SUMMARY
          echo "- [🏷️ 项目Releases](https://github.com/${{ github.repository }}/releases)" >> $GITHUB_STEP_SUMMARY

      # 11. 通知失败
      - name: 🚨 Notify on Failure
        if: failure()
        run: |
          echo "## ❌ 发布失败" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 常见问题排查" >> $GITHUB_STEP_SUMMARY
          echo "1. **NPM Token**: 检查 \`NPM_TOKEN\` secret 是否正确配置" >> $GITHUB_STEP_SUMMARY
          echo "2. **权限问题**: 确认账号对包有发布权限" >> $GITHUB_STEP_SUMMARY
          echo "3. **版本冲突**: 检查包版本是否已存在" >> $GITHUB_STEP_SUMMARY
          echo "4. **构建失败**: 查看构建步骤的错误信息" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📋 请查看上方的详细日志进行问题排查。"